import {
  Component,
  ComponentContext,
  ComponentDef,
  ComponentMount,
  DefaultRenderScheduler,
  Feature,
  ShadowContentRoot,
} from '@wesib/wesib';
import { trackValue } from 'fun-events';
import { immediateRenderScheduler } from 'render-scheduler';
import { StypProperties, StypRenderer, stypRoot, StypRules, stypSelectorText } from 'style-producer';
import { testComponentFactory } from '../spec/test-element';
import { BasicStyleProducerSupport } from './basic-style-producer-support.feature';
import { ComponentStypOptions } from './component-styp-options';
import { ComponentStypRenderer } from './component-styp-renderer';
import { ElementIdClass } from './element-id-class.impl';
import { ProduceStyle } from './produce-style.decorator';
import { StyleProducerSupport } from './style-producer-support.feature';

describe('styp', () => {
  describe('@ProduceStyle', () => {

    let element: HTMLElement;

    beforeEach(() => {
      element = document.createElement('test-component') as any;
      document.body.append(element);
    });
    afterEach(() => {
      element.remove();
    });

    it('renders style', async () => {
      await mount();
      expect(cssStyle().display).toBe('block');
    });
    it('renders styles', async () => {
      await mount(stypRoot({ display: 'block' }).rules);
      expect(cssStyle().display).toBe('block');
    });
    it('renders styles with StyleProducerSupport', async () => {
      await mount(stypRoot({ display: 'block' }).rules, { feature: { needs: StyleProducerSupport } });
      expect(cssStyle().display).toBe('block');
    });
    it('renders styles generated by function', async () => {
      await mount(() => stypRoot({ display: 'block' }).rules);
      expect(cssStyle().display).toBe('block');
    });
    it('renders styles immediately when `offline="always"`', async () => {
      await mount(undefined, undefined, { offline: 'always' });
      expect(cssStyle().display).toBe('block');
    });
    it('renders styles using component CSS renderer', async () => {

      const mockRenderer = jest.fn<void, Parameters<StypRenderer.Function>>(
          (producer, properties) => producer.render(properties),
      );

      await mount(
          undefined,
          {
            setup(setup) {
              setup.perComponent({ a: ComponentStypRenderer, is: mockRenderer });
            },
          },
      );
      expect(cssStyle().display).toBe('block');
      expect(mockRenderer).toHaveBeenCalledWith(expect.anything(), { display: 'block' });
    });
    it('removes styles on disconnection when `offline=false`', async () => {

      const mnt = await mount(undefined, undefined, { offline: false });

      mnt.connected = false;
      expect(mnt.context.element.querySelectorAll('style')).toHaveLength(0);
    });
    it('does not remove styles on disconnection', async () => {

      const mnt = await mount();

      mnt.connected = false;
      expect(cssStyle().display).toBe('block');
    });
    it('removes styles on component destruction', async () => {

      const mnt = await mount();

      mnt.context.destroy();
      expect(mnt.context.element.querySelectorAll('style')).toHaveLength(0);
    });
    it('updates style', async () => {

      const css = trackValue<StypProperties>({ display: 'block' });

      await mount(stypRoot(css));

      css.it = { display: 'inline-block' };
      expect(cssStyle().display).toBe('inline-block');
    });
    it('prepends element id class to CSS rule selector', async () => {

      const context = (await mount()).context;
      const rule = cssStyleRule();
      const idClass = context.get(ElementIdClass);

      expect(rule.selectorText).toBe(stypSelectorText({ c: idClass }));
    });
    it('prepends element id class to CSS rule selector of anonymous component', async () => {

      const context = (await mount(undefined, {})).context;
      const rule = cssStyleRule();
      const idClass = context.get(ElementIdClass);
      const selector = stypSelectorText({ c: idClass });

      expect(rule.selectorText).toBe(selector);
      expect(selector).toMatch(/^\.component\\#\d+\\@/);
    });
    it('prepends `:host` CSS rule selector when shadow DOM supported', async () => {
      await mount(undefined, {
        setup(setup) {
          setup.perComponent({
            a: ShadowContentRoot,
            by(ctx: ComponentContext) {
              return ctx.element;
            },
          });
        },
      });

      const rule = cssStyleRule();

      expect(rule.selectorText).toBe(':host');
    });

    async function mount(
        rules: StypRules.Source = stypRoot({ display: 'block' }),
        def: ComponentDef = { name: 'test-component' },
        options?: ComponentStypOptions,
    ): Promise<ComponentMount> {

      @Component(def)
      @Feature({
        needs: BasicStyleProducerSupport,
        setup(setup) {
          setup.provide({
            a: DefaultRenderScheduler,
            is: immediateRenderScheduler,
          });
        },
      })
      class TestComponent {

        @ProduceStyle(options)
        get style(): StypRules.Source {
          return rules;
        }

      }

      const factory = await testComponentFactory(TestComponent);

      return factory.mountTo(element);
    }

    function cssStyle(): CSSStyleDeclaration {
      return cssStyleRule().style;
    }

    function cssStyleRule(): CSSStyleRule {

      const styles = element.querySelectorAll('style');

      expect(styles).toHaveLength(1);

      const style = styles[0];
      const sheet = style.sheet as CSSStyleSheet;
      const rule = sheet.cssRules[0] as CSSStyleRule;

      expect(rule).toBeDefined();

      return rule;
    }
  });
});
